2021-1-2 工程Code的必要条件:Git,blob,tree,commit

**1.为什么需要Git? **

对于初学编程的新人来说，git是非常难以理解的工具。

因为在日常学习中，几乎不会遇到要必须使用git这类版本代码控制工具的场景。

通常来说，新人的代码控制就是根据日期来的，比如建立一个文件夹【2021年1月1号代码学习】

然后第二天 就是【2021年1月2号代码学习】....

没错，其实我在大学的时候就是差不多按照这样来的...直到和一位已经工作的大佬交流后...

其实前面的建立日期文件夹，已经有git的一些思想在里面：代码的改变是按照时间先后顺序来的。

这看起来是一句废话。

我们先设想这样一个实际工作场景：

有一个项目，同时有一百位程序猿在开发，且这一百位同学身处各个地方，并不是在同一个局域网下。且每时每刻都有人在修改源代码。

那么问题来了，如果突然项目运行出bug了，那么怎么找到Bug源头，并且将项目恢复到正常状态。

假设按照我们最初级的想法

每一次的代码修改都有一个备份，或者说一个快照，精确到毫秒级别的修改。

这种版本的备份一般有两种方式：

第一就是全量备份，也就是每次备份都是复制所有的项目代码。

第二就是变量备份，只负责备份修改的那部分代码。

比如时间版本

2021-1-3-14:23:25:36,

2021-1-3-14:23:25:38

2021-1-3-14:23:26:16

2021-1-3-14:28:12:06

那么当2021-1-3-14:28:12遇到BUG问题的时候，只需要将代码恢复到最新的正常的时间线，也就是2021-1-3 14:23:26:16。

这也就是版本控制的一种简单理解。

版本控制这个说法多少有一点抽象。

事实上，版本控制这件事儿我们一直在做，只是平时不这么称呼。

举一个栗子，你是个设计，甲方让做一份设计方案，你先完成了一稿，之后又有了一些新的想法，但是并不确定新的想法是否能得到甲方的认可，于是你保存了一个**初稿**，之后在初稿的基础上另存了一个文件，做了部分修改完成了一个**修改稿**。OK，这时你的设计就有了两个版本——初稿和修改稿。如果甲方对**修改稿**不满意，你可以很轻易的把**初稿**拿出来交差。

在这个简单的过程中，你已经执行了一个简单的版本控制操作——把文档保存为初稿和修改稿的过程就是版本控制。

学术点说，版本控制就是对文件**变更过程**的管理。

**2、Git能够解决哪些问题？**

就像上文举的例子一样，在未接触版本控制系统之前，大多人会通过保存项目或文件的备份来达到版本控制的目的。通常你的文件或文件夹名会设置成“XXX-v1.0”、“XXX-v2.0”等。

这是一种简单的办法，但过于简单。这种方式无法详细记录版本附加信息，难以应付复杂项目或长期更新的项目，缺乏版本控制约定，对协作开发无能为力。如果你不慎使用了这种方式，那么稍稍过一段时间你就会发现连自己都不知道每个版本间的区别，版本控制形同虚设。

git能够为我们解决版本控制方面的大多数问题，利用Git

- 我们可以为每一次变更提交版本更新并且备注更新的内容；
- 我们可以在项目的各个历史版本之间自如切换；
- 我们可以一目了然的比较出两个版本之间的差异；
- 我们可以从当前的修改中撤销一些操作；
- 我们可以自如的创建分支、合并分支；
- 我们可以和多人协作开发；
- 我们可以采取自由多样的开发模式。

诸如此类，数不胜数。然而实现这些功能的基础是**对文件变更过程的存储**。



~~**3. 如果让你来设计一个git **~~ 谈谈git的blob,tree,commit

~~你肯定设计不出来....~~

我们不是linus,这事儿明显超纲了。

我们从git内核的三大部分入手，blob表示数据，tree表示blob数据存储结构，commit表示一次提交，有parent字段。

1. blob

   用来存放项目文件的内容，但是不包括文件的路径、名字、格式等其它描述信息。项目的任意文件的任意版本都是以blob的形式存放的。

2. tree

   tree 用来表示目录。我们知道项目就是一个目录，目录中有文件、有子目录。因此 tree 中有 blob、子tree，且都是使用 sha-1值引用的。这是与目录对应的。从顶层的 tree 纵览整个树状的结构，叶子结点就是blob，表示文件的内容，非叶子结点表示项目的目录，顶层的 tree 对象就代表了当前项目的快照。

3. commit

   commit: 表示一次提交，有parent字段，用来引用父提交。指向了一个顶层 tree，表示了项目的快照，还有一些其它的信息，比如上一个提交，committer、author、message 等信息。

**Git 对象blob**

先从本地创建一个空git仓库开始,然后进去隐藏的.git文件夹

```
$ cd f:/
$ mkdir git_test
$ cd git_test
$ git init
Initialized empty Git repository in F:/git_test/.git/
$ ls -a
./  ../  .git/
SheepHerder@DESKTOP-INQLCNB MINGW64 /f/git_test (main)
$ cd .git/
SheepHerder@DESKTOP-INQLCNB MINGW64 /f/git_test/.git (GIT_DIR!)
$ ls
HEAD  config  description  hooks/  info/  objects/  refs/
```

<img src="C:\Users\SheepHerder\AppData\Roaming\Typora\typora-user-images\image-20210103161243189.png" alt="image-20210103161243189" style="zoom:200%;" />

- description文件仅供GitWeb使用，不用关心它。
- config文件包含了项目特有的配置选项，如最常用的用户名和邮箱。
- info目录保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局可执行文件。这个用得比较少，也不用太关心。
- hooks目录保存了客户端或服务端钩子脚本，一般我们都是用默认的，很少改，也不用太关心。

因此，我们需要重点关心另外四个重要的文件或目录：HEAD和index文件，objects和refs目录，因为它们是Git的核心：

- objects 目录存储所有数据内容。

- refs 目录存储指向数据 (分支) 的提交对象的指针。

- HEAD 文件指向当前分支。

- index 文件保存了暂存区域信息。

  

```
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
```

Git 初始化了 objects 目录，同时在该目录下创建了 pack 和 info 子目录，但是该目录下没有其他常规文件

接下来，我们新建一个文件test.txt，内容为hello git，并把它加入暂存区

```
$ vim test.txt
$ git add test1.txt
```

发现.git目录下多了2个文件，且内容都为字节码：

```
.git/
|--index
|--objects
|   |--8d
|   |   |-- 0e41234f24b6da002d962a26c2495ea16a425f
```

使用如下命令查看test.txt的hash值

```
$ git hash-object test.txt
8d0e41234f24b6da002d962a26c2495ea16a425f
```

发现结果的前2位是文件夹的名字，后38位是文件的名字。

0e41234f24b6da002d962a26c2495ea16a425f这个文件是用zlib压缩的

通过git cat-file 命令可取出文件存储的内容

```
$ git cat-file -p 8d0e41234f24b6da002d962a26c2495ea16a425f
hello git
```

看看index文件，刚刚了解了index 文件保存了暂存区域信息， 用git ls-files —stage命令可查看index内容

```
$ git ls-files --stage
100644  8d0e41234f24b6da002d962a26c2495ea16a425f 0    test1.txt
```

根据官方文档，git使用‘blob’+len(content)+'\0'+content

其中’blob‘ + len(content) + ‘\0’ 来组成一个header，然后再将这个header与真正的内容拼接起来，并计算拼接后的新内容的 SHA-1 校验和。







